// This file was generated by json2swift.

import Foundation

public struct Evolution: Codable, Hashable, Equatable {
	
	public static func == (lhs: Evolution, rhs: Evolution) -> Bool {
		return lhs.evolutionID == rhs.evolutionID
	}
	
	public var hashValue: Int {
		return evolutionID
	}
	
	public enum Trigger: String, Codable {
		case levelUp = "level up", trade, item = "Item", shed
	}
	
	public enum Modifier: Double, Codable {
		case superEffective = 2.0
		case notVerEffective = 0.5
	}
	
	public let evolutionID: Int
	public let evolvedSpeciesID: Int
	public let gender: String?
	public let heldItem: String?
	public let inVersion: String?
	public let knownMove: String?
	public let knownMoveType: String?
	public let location: String?
	public let minimumAffection: Int?
	public let minimumHappiness: Int?
	public let minimumLevel: Int?
	public let originalSpeciesID: Int
	public let partySpecies: String?
	public let partyType: String?
	public let relativePhysicalStats: Int?
	public let timeOfDay: String?
	public let tradeSpecies: String?
	public let trigger: Trigger
	public let triggerItem: String?
	public var specialCondition: String?
	
	enum CodingKeys: String, CodingKey {
		case evolutionID = "evolution ID", evolvedSpeciesID = "evolved species ID", originalSpeciesID = "original species ID", trigger, specialCondition = "special condition", gender, heldItem = "held item", inVersion = "in version", knownMove = "known move", knownMoveType = "known move type", location, minimumAffection = "minimum affection", minimumHappiness = "minimum happiness", minimumLevel = "minimum level", partySpecies = "party species", partyType = "party type", relativePhysicalStats = "relative physical stats", timeOfDay = "time of day", tradeSpecies = "trade speceis", triggerItem = "trigger item"
	}
	
	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: CodingKeys.self)
		evolutionID = try container.decode(Int.self, forKey: .evolutionID)
		evolvedSpeciesID = try container.decode(Int.self, forKey: .evolvedSpeciesID)
		gender = try container.decodeIfPresent(String.self, forKey: .gender)
		heldItem = try container.decodeIfPresent(String.self, forKey: .heldItem)
		inVersion = try container.decodeIfPresent(String.self, forKey: .inVersion)
		knownMove = try container.decodeIfPresent(String.self, forKey: .knownMove)
		knownMoveType = try container.decodeIfPresent(String.self, forKey: .knownMoveType)
		location = try container.decodeIfPresent(String.self, forKey: .location)
		minimumAffection = try container.decodeIfPresent(Int.self, forKey: .minimumAffection)
		minimumHappiness = try container.decodeIfPresent(Int.self, forKey: .minimumHappiness)
		minimumLevel = try container.decodeIfPresent(Int.self, forKey: .minimumLevel)
		originalSpeciesID = try container.decode(Int.self, forKey: .originalSpeciesID)
		partySpecies = try container.decodeIfPresent(String.self, forKey: .partySpecies)
		partyType = try container.decodeIfPresent(String.self, forKey: .partyType)
		relativePhysicalStats = try container.decodeIfPresent(Int.self, forKey: .relativePhysicalStats)
		timeOfDay = try container.decodeIfPresent(String.self, forKey: .timeOfDay)
		tradeSpecies = try container.decodeIfPresent(String.self, forKey: .tradeSpecies)
		trigger = try container.decode(Trigger.self, forKey: .trigger)
		triggerItem = try container.decodeIfPresent(String.self, forKey: .triggerItem)
		specialCondition = try container.decodeIfPresent(String.self, forKey: .specialCondition)
	}
	
	public var conditions: String {
		var conditions = [String]()
		
		switch trigger {
		case .levelUp:
			if let minimumLevel = minimumLevel {
				conditions.append("at level \(minimumLevel)")
			} else {
				conditions.append("when leveled up")
			}
		case .trade:
			conditions.append("when traded")
		case .item where triggerItem != nil:
			conditions.append("using a \(triggerItem!)")
		default:
			conditions.append("using an item")
		}
		if let tradeSpecies = tradeSpecies {
			conditions.append("for a \(tradeSpecies)")
		}
		if let timeOfDay = timeOfDay {
			if timeOfDay == "day" {
				conditions.append("during the day")
			} else if timeOfDay == "night" {
				conditions.append("at night")
			}
		}
		if let _ = minimumAffection {
			conditions.append("with high affection")
		}
		if let heldItem = heldItem {
			conditions.append("while holding \(heldItem)")
		}
		if let version = inVersion {
			conditions.append("in \(version)")
		}
		if let knownMove = knownMove {
			conditions.append("while knowing \(knownMove)")
		}
		if let knownMoveType = knownMoveType {
			conditions.append("while knowing a \(knownMoveType)-type Move")
		}
		if let location = location {
			conditions.append("at \(location)")
		}
		if let _ = minimumHappiness {
			conditions.append("with high friendship")
		}
		if let partySpecies = partySpecies {
			conditions.append("with a \(partySpecies) in the party")
		}
		if let partyType = partyType {
			conditions.append("with a \(partyType)-type Pokémon in the party")
		}
		if let relativePhysicalStats = relativePhysicalStats {
			switch relativePhysicalStats {
			case -1: conditions.append("if its Attack is higher than its Defense")
			case 0: conditions.append("if its Attack and Defense are the same")
			case 1: conditions.append("if its Defense is higher than its Attack")
			default: break
			}
		}
		if let specialCondition = specialCondition {
			conditions.append(specialCondition)
		}
		if let gender = gender {
			conditions.append("(if \(gender))")
		}
		
		return conditions.joined(separator: " ")
	}
	
	public static func with(id: Int) -> Evolution? {
		return try? Pokédex.decode(Evolution.self, fromPropertyListWithName: "evolution-\(id)")
	}
}
