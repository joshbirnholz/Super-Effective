// This file was generated by json2swift.

import Foundation

//
// MARK: - Data Model
//
public struct TypeMatchup: Codable {
	public let defendingType: TypeCombination
	public let effectiveness: [Type : Double]
	
	public init(defendingType: TypeCombination, effectiveness: [Type : Double]) {
		self.defendingType = defendingType
		self.effectiveness = effectiveness
	}
	
	private enum TypeMatchupCodingKeys: String, CodingKey, CaseIterable {
		case defenseType1 = "defense-type1"
		case defenseType2 = "defense-type2"
		case normal, fire, fighting, water, flying, grass, poison, electric, ground, psychic, rock, ice, bug, dragon, ghost, dark, steel, fairy
	}
	
	public init(from decoder: Decoder) throws {
		let values = try decoder.container(keyedBy: TypeMatchupCodingKeys.self)
		
		let type1 = try values.decode(Type.self, forKey: .defenseType1)
		let type2 = try? values.decode(Type.self, forKey: .defenseType2)
		
		let combination = TypeCombination(type1, type2)
		
		var effectiveness: [Type : Double] = [:]
		
		for type in TypeMatchupCodingKeys.allCases where type != .defenseType1 && type != .defenseType2 {
			guard let actualType = Type(rawValue: type.rawValue) else {
				continue
			}
			let value = try values.decode(Double.self, forKey: type)
			effectiveness[actualType] = value
		}
		
		self.defendingType = combination
		self.effectiveness = effectiveness
	}
	
	private static let chart = [
		[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0.5, 0, 1, 1, 0.5, 1, 1],// Normal
		[1, 0.5, 0.5, 1, 2, 2, 1, 1, 1, 1, 1, 2, 0.5, 1, 0.5, 1, 2, 1, 1],// Fire
		[1, 2, 0.5, 1, 0.5, 1, 1, 1, 2, 1, 1, 1, 2, 1, 0.5, 1, 1, 1, 1],// Water
		[1, 1, 2, 0.5, 0.5, 1, 1, 1, 0, 2, 1, 1, 1, 1, 0.5, 1, 1, 1, 1],// Electric
		[1, 0.5, 2, 1, 0.5, 1, 1, 0.5, 2, 0.5, 1, 0.5, 2, 1, 0.5, 1, 0.5, 1, 1],// Grass
		[1, 0.5, 0.5, 1, 2, 0.5, 1, 1, 2, 2, 1, 1, 1, 1, 2, 1, 0.5, 1, 1],// Ice
		[2, 1, 1, 1, 1, 2, 1, 0.5, 1, 0.5, 0.5, 0.5, 2, 0, 1, 2, 2, 0.5, 1],// Fighting
		[1, 1, 1, 1, 2, 1, 1, 0.5, 0.5, 1, 1, 1, 0.5, 0.5, 1, 1, 0, 2, 1],// Poison
		[1, 2, 1, 2, 0.5, 1, 1, 2, 1, 0, 1, 0.5, 2, 1, 1, 1, 2, 1, 1],// Ground
		[1, 1, 1, 0.5, 2, 1, 2, 1, 1, 1, 1, 2, 0.5, 1, 1, 1, 0.5, 1, 1],// Flying
		[1, 1, 1, 1, 1, 1, 2, 2, 1, 1, 0.5, 1, 1, 1, 1, 0, 0.5, 1, 1],// Psychic
		[1, 0.5, 1, 1, 2, 1, 0.5, 0.5, 1, 0.5, 2, 1, 1, 0.5, 1, 2, 0.5, 0.5, 1],// Bug
		[1, 2, 1, 1, 1, 2, 0.5, 1, 0.5, 2, 1, 2, 1, 1, 1, 1, 0.5, 1, 1],// Rock
		[0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 1, 2, 1, 0.5, 1, 1, 1],// Ghost
		[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 1, 0.5, 0, 1],// Dragon
		[1, 1, 1, 1, 1, 1, 0.5, 1, 1, 1, 2, 1, 1, 2, 1, 0.5, 1, 0.5, 1],// Dark
		[1, 0.5, 0.5, 0.5, 1, 2, 1, 1, 1, 1, 1, 1, 2, 1, 1, 1, 0.5, 2, 1],// Steel
		[1, 0.5, 1, 1, 1, 1, 2, 0.5, 1, 1, 1, 1, 1, 1, 2, 2, 0.5, 1, 1],// Fairy
		[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]// None
	]
	
	private static let typeNames: [Type?] = [.normal, .fire, .water, .electric, .grass, .ice, .fighting, .poison, .ground, .flying, .psychic, .bug, .rock, .ghost, .dragon, .dark, .steel, .fairy, nil]
	
	public init(defendingType: TypeCombination) {
		
		var effectiveness: [Type: Double] = [:]
		
		let type1Index = TypeMatchup.typeNames.compactMap({$0}).firstIndex(of: defendingType.type1)!
		let type2Index = TypeMatchup.typeNames.firstIndex(of: defendingType.type2)!
		
		for (index, type) in TypeMatchup.typeNames.compactMap({ $0 }).enumerated() {
			let a = TypeMatchup.chart[index][type1Index]
			let b = TypeMatchup.chart[index][type2Index]
			
			effectiveness[type] = a * b
		}
		
		self.defendingType = defendingType
		self.effectiveness = effectiveness
		
	}
	
}
